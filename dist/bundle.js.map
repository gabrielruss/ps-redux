{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 1cb9ed232efd5edb24e0","webpack:///./~/eventsource-polyfill/dist/browserify-eventsource.js","webpack:///./~/eventsource-polyfill/dist/eventsource.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","PolyfillEventSource","EventSource","window","console","log","global","MessageEvent","type","data","origin","lastEventId","this","bubbles","cancelBubble","cancelable","isOldIE","XDomainRequest","XMLHttpRequest","undefined","responseType","_eventSourceImportPrefix","evsImportName","url","options","SyntaxError","URL","setOptions","evs","setTimeout","poll","prototype","CONNECTING","OPEN","CLOSED","defaultOptions","loggingEnabled","loggingPrefix","interval","bufferSizeLimit","silentTimeout","getArgs","evs_buffer_size_limit","xhrHeaders","Accept","Cache-Control","X-Requested-With","option","defaults","hasOwnProperty","message","readyState","cleanup","cursor","cache","_xhr","XHR","resetNoActivityTimer","e","dispatchEvent","pollAgain","_pollTimer","clearInterval","_noActivityTimer","abort","close","ondata","request","isReady","hasError","buffer","getBuffer","length","substring","lastMessageIndex","newcursor","toparse","parseStream","isDone","chunk","normalizeToLF","i","j","eventType","datas","line","retry","events","split","parts","trimWhiteSpace","indexOf","replace","parseInt","isNaN","push","event","join","location","handlers","addEventListener","handler","removeEventListener","splice","_noactivityTimer","onerror","onmessage","onopen","urlWithParams","baseURL","params","encodedArgs","key","urlarg","urlize","encodeURIComponent","text","ln2","lastIndexOf","lr2","lrln2","Math","max","str","reTrim","isPolyfill","_request","onprogress","_ready","onload","_loaded","_failed","ontimeout","reqGetArgs","defaultArgs","open","send","useXDomainRequest","rv","responseText","onreadystatechange","status","headers","header","setRequestHeader"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t   * CommonJS module that exports EventSource polyfill version 0.9.6\n\t   * This module is intended for browser side use\n\t   * =====================================================================\n\t   * THIS IS A POLYFILL MODULE, SO IT HAS SIDE EFFECTS\n\t   * IT AUTOMATICALLY CHECKS IF window OBJECT DEFINES EventSource\n\t   * AND ADD THE EXPORTED ONE IN CASE IT IS UNDEFINED\n\t   * =====================================================================\n\t   * Supported by sc AmvTek srl\n\t   * :email: devel@amvtek.com\n\t */\n\t\n\t\n\tvar PolyfillEventSource = __webpack_require__(1).EventSource;\n\tmodule.exports = PolyfillEventSource;\n\t\n\t// Add EventSource to window if it is missing...\n\tif (window && !window.EventSource){\n\t    window.EventSource = PolyfillEventSource;\n\t    if (console){\n\t\tconsole.log(\"polyfill-eventsource added missing EventSource to window\");\n\t    }\n\t}\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/*\n\t   * EventSource polyfill version 0.9.6\n\t   * Supported by sc AmvTek srl\n\t   * :email: devel@amvtek.com\n\t */\n\t;(function (global) {\n\t\n\t    if (global.EventSource && !global._eventSourceImportPrefix){\n\t        return;\n\t    }\n\t\n\t    var evsImportName = (global._eventSourceImportPrefix||'')+\"EventSource\";\n\t\n\t    var EventSource = function (url, options) {\n\t\n\t        if (!url || typeof url != 'string') {\n\t            throw new SyntaxError('Not enough arguments');\n\t        }\n\t\n\t        this.URL = url;\n\t        this.setOptions(options);\n\t        var evs = this;\n\t        setTimeout(function(){evs.poll()}, 0);\n\t    };\n\t\n\t    EventSource.prototype = {\n\t\n\t        CONNECTING: 0,\n\t\n\t        OPEN: 1,\n\t\n\t        CLOSED: 2,\n\t\n\t        defaultOptions: {\n\t\n\t            loggingEnabled: false,\n\t\n\t            loggingPrefix: \"eventsource\",\n\t\n\t            interval: 500, // milliseconds\n\t\n\t            bufferSizeLimit: 256*1024, // bytes\n\t\n\t            silentTimeout: 300000, // milliseconds\n\t\n\t            getArgs:{\n\t                'evs_buffer_size_limit': 256*1024\n\t            },\n\t\n\t            xhrHeaders:{\n\t                'Accept': 'text/event-stream',\n\t                'Cache-Control': 'no-cache',\n\t                'X-Requested-With': 'XMLHttpRequest'\n\t            }\n\t        },\n\t\n\t        setOptions: function(options){\n\t\n\t            var defaults = this.defaultOptions;\n\t            var option;\n\t\n\t            // set all default options...\n\t            for (option in defaults){\n\t\n\t                if ( defaults.hasOwnProperty(option) ){\n\t                    this[option] = defaults[option];\n\t                }\n\t            }\n\t\n\t            // override with what is in options\n\t            for (option in options){\n\t\n\t                if (option in defaults && options.hasOwnProperty(option)){\n\t                    this[option] = options[option];\n\t                }\n\t            }\n\t\n\t            // if getArgs option is enabled\n\t            // ensure evs_buffer_size_limit corresponds to bufferSizeLimit\n\t            if (this.getArgs && this.bufferSizeLimit) {\n\t\n\t                this.getArgs['evs_buffer_size_limit'] = this.bufferSizeLimit;\n\t            }\n\t\n\t            // if console is not available, force loggingEnabled to false\n\t            if (typeof console === \"undefined\" || typeof console.log === \"undefined\") {\n\t\n\t                this.loggingEnabled = false;\n\t            }\n\t        },\n\t\n\t        log: function(message) {\n\t\n\t            if (this.loggingEnabled) {\n\t\n\t                console.log(\"[\" + this.loggingPrefix +\"]:\" + message)\n\t            }\n\t        },\n\t\n\t        poll: function() {\n\t\n\t            try {\n\t\n\t                if (this.readyState == this.CLOSED) {\n\t                    return;\n\t                }\n\t\n\t                this.cleanup();\n\t                this.readyState = this.CONNECTING;\n\t                this.cursor = 0;\n\t                this.cache = '';\n\t                this._xhr = new this.XHR(this);\n\t                this.resetNoActivityTimer();\n\t\n\t            }\n\t            catch (e) {\n\t\n\t                // in an attempt to silence the errors\n\t                this.log('There were errors inside the pool try-catch');\n\t                this.dispatchEvent('error', { type: 'error', data: e.message });\n\t            }\n\t        },\n\t\n\t        pollAgain: function (interval) {\n\t\n\t            // schedule poll to be called after interval milliseconds\n\t            var evs = this;\n\t            evs.readyState = evs.CONNECTING;\n\t            evs.dispatchEvent('error', {\n\t                type: 'error',\n\t                data: \"Reconnecting \"\n\t            });\n\t            this._pollTimer = setTimeout(function(){evs.poll()}, interval||0);\n\t        },\n\t\n\t\n\t        cleanup: function() {\n\t\n\t            this.log('evs cleaning up')\n\t\n\t            if (this._pollTimer){\n\t                clearInterval(this._pollTimer);\n\t                this._pollTimer = null;\n\t            }\n\t\n\t            if (this._noActivityTimer){\n\t                clearInterval(this._noActivityTimer);\n\t                this._noActivityTimer = null;\n\t            }\n\t\n\t            if (this._xhr){\n\t                this._xhr.abort();\n\t                this._xhr = null;\n\t            }\n\t        },\n\t\n\t        resetNoActivityTimer: function(){\n\t\n\t            if (this.silentTimeout){\n\t\n\t                if (this._noActivityTimer){\n\t                    clearInterval(this._noActivityTimer);\n\t                }\n\t                var evs = this;\n\t                this._noActivityTimer = setTimeout(\n\t                        function(){ evs.log('Timeout! silentTImeout:'+evs.silentTimeout); evs.pollAgain(); },\n\t                        this.silentTimeout\n\t                        );\n\t            }\n\t        },\n\t\n\t        close: function () {\n\t\n\t            this.readyState = this.CLOSED;\n\t            this.log('Closing connection. readyState: '+this.readyState);\n\t            this.cleanup();\n\t        },\n\t\n\t        ondata: function() {\n\t\n\t            var request = this._xhr;\n\t\n\t            if (request.isReady() && !request.hasError() ) {\n\t                // reset the timer, as we have activity\n\t                this.resetNoActivityTimer();\n\t\n\t                // move this EventSource to OPEN state...\n\t                if (this.readyState == this.CONNECTING) {\n\t                    this.readyState = this.OPEN;\n\t                    this.dispatchEvent('open', { type: 'open' });\n\t                }\n\t\n\t                var buffer = request.getBuffer();\n\t\n\t                if (buffer.length > this.bufferSizeLimit) {\n\t                    this.log('buffer.length > this.bufferSizeLimit');\n\t                    this.pollAgain();\n\t                }\n\t\n\t                if (this.cursor == 0 && buffer.length > 0){\n\t\n\t                    // skip byte order mark \\uFEFF character if it starts the stream\n\t                    if (buffer.substring(0,1) == '\\uFEFF'){\n\t                        this.cursor = 1;\n\t                    }\n\t                }\n\t\n\t                var lastMessageIndex = this.lastMessageIndex(buffer);\n\t                if (lastMessageIndex[0] >= this.cursor){\n\t\n\t                    var newcursor = lastMessageIndex[1];\n\t                    var toparse = buffer.substring(this.cursor, newcursor);\n\t                    this.parseStream(toparse);\n\t                    this.cursor = newcursor;\n\t                }\n\t\n\t                // if request is finished, reopen the connection\n\t                if (request.isDone()) {\n\t                    this.log('request.isDone(). reopening the connection');\n\t                    this.pollAgain(this.interval);\n\t                }\n\t            }\n\t            else if (this.readyState !== this.CLOSED) {\n\t\n\t                this.log('this.readyState !== this.CLOSED');\n\t                this.pollAgain(this.interval);\n\t\n\t                //MV: Unsure why an error was previously dispatched\n\t            }\n\t        },\n\t\n\t        parseStream: function(chunk) {\n\t\n\t            // normalize line separators (\\r\\n,\\r,\\n) to \\n\n\t            // remove white spaces that may precede \\n\n\t            chunk = this.cache + this.normalizeToLF(chunk);\n\t\n\t            var events = chunk.split('\\n\\n');\n\t\n\t            var i, j, eventType, datas, line, retry;\n\t\n\t            for (i=0; i < (events.length - 1); i++) {\n\t\n\t                eventType = 'message';\n\t                datas = [];\n\t                parts = events[i].split('\\n');\n\t\n\t                for (j=0; j < parts.length; j++) {\n\t\n\t                    line = this.trimWhiteSpace(parts[j]);\n\t\n\t                    if (line.indexOf('event') == 0) {\n\t\n\t                        eventType = line.replace(/event:?\\s*/, '');\n\t                    }\n\t                    else if (line.indexOf('retry') == 0) {\n\t\n\t                        retry = parseInt(line.replace(/retry:?\\s*/, ''));\n\t                        if(!isNaN(retry)) {\n\t                            this.interval = retry;\n\t                        }\n\t                    }\n\t                    else if (line.indexOf('data') == 0) {\n\t\n\t                        datas.push(line.replace(/data:?\\s*/, ''));\n\t                    }\n\t                    else if (line.indexOf('id:') == 0) {\n\t\n\t                        this.lastEventId = line.replace(/id:?\\s*/, '');\n\t                    }\n\t                    else if (line.indexOf('id') == 0) { // this resets the id\n\t\n\t                        this.lastEventId = null;\n\t                    }\n\t                }\n\t\n\t                if (datas.length) {\n\t                    // dispatch a new event\n\t                    var event = new MessageEvent(eventType, datas.join('\\n'), window.location.origin, this.lastEventId);\n\t                    this.dispatchEvent(eventType, event);\n\t                }\n\t            }\n\t\n\t            this.cache = events[events.length - 1];\n\t        },\n\t\n\t        dispatchEvent: function (type, event) {\n\t            var handlers = this['_' + type + 'Handlers'];\n\t\n\t            if (handlers) {\n\t\n\t                for (var i = 0; i < handlers.length; i++) {\n\t                    handlers[i].call(this, event);\n\t                }\n\t            }\n\t\n\t            if (this['on' + type]) {\n\t                this['on' + type].call(this, event);\n\t            }\n\t\n\t        },\n\t\n\t        addEventListener: function (type, handler) {\n\t            if (!this['_' + type + 'Handlers']) {\n\t                this['_' + type + 'Handlers'] = [];\n\t            }\n\t\n\t            this['_' + type + 'Handlers'].push(handler);\n\t        },\n\t\n\t        removeEventListener: function (type, handler) {\n\t            var handlers = this['_' + type + 'Handlers'];\n\t            if (!handlers) {\n\t                return;\n\t            }\n\t            for (var i = handlers.length - 1; i >= 0; --i) {\n\t                if (handlers[i] === handler) {\n\t                    handlers.splice(i, 1);\n\t                    break;\n\t                }\n\t            }\n\t        },\n\t\n\t        _pollTimer: null,\n\t\n\t        _noactivityTimer: null,\n\t\n\t        _xhr: null,\n\t\n\t        lastEventId: null,\n\t\n\t        cache: '',\n\t\n\t        cursor: 0,\n\t\n\t        onerror: null,\n\t\n\t        onmessage: null,\n\t\n\t        onopen: null,\n\t\n\t        readyState: 0,\n\t\n\t        // ===================================================================\n\t        // helpers functions\n\t        // those are attached to prototype to ease reuse and testing...\n\t\n\t        urlWithParams: function (baseURL, params) {\n\t\n\t            var encodedArgs = [];\n\t\n\t            if (params){\n\t\n\t                var key, urlarg;\n\t                var urlize = encodeURIComponent;\n\t\n\t                for (key in params){\n\t                    if (params.hasOwnProperty(key)) {\n\t                        urlarg = urlize(key)+'='+urlize(params[key]);\n\t                        encodedArgs.push(urlarg);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (encodedArgs.length > 0){\n\t\n\t                if (baseURL.indexOf('?') == -1)\n\t                    return baseURL + '?' + encodedArgs.join('&');\n\t                return baseURL + '&' + encodedArgs.join('&');\n\t            }\n\t            return baseURL;\n\t        },\n\t\n\t        lastMessageIndex: function(text) {\n\t\n\t            var ln2 =text.lastIndexOf('\\n\\n');\n\t            var lr2 = text.lastIndexOf('\\r\\r');\n\t            var lrln2 = text.lastIndexOf('\\r\\n\\r\\n');\n\t\n\t            if (lrln2 > Math.max(ln2, lr2)) {\n\t                return [lrln2, lrln2+4];\n\t            }\n\t            return [Math.max(ln2, lr2), Math.max(ln2, lr2) + 2]\n\t        },\n\t\n\t        trimWhiteSpace: function(str) {\n\t            // to remove whitespaces left and right of string\n\t\n\t            var reTrim = /^(\\s|\\u00A0)+|(\\s|\\u00A0)+$/g;\n\t            return str.replace(reTrim, '');\n\t        },\n\t\n\t        normalizeToLF: function(str) {\n\t\n\t            // replace \\r and \\r\\n with \\n\n\t            return str.replace(/\\r\\n|\\r/g, '\\n');\n\t        }\n\t\n\t    };\n\t\n\t    if (!isOldIE()){\n\t\n\t        EventSource.isPolyfill = \"XHR\";\n\t\n\t        // EventSource will send request using XMLHttpRequest\n\t        EventSource.prototype.XHR = function(evs) {\n\t\n\t            request = new XMLHttpRequest();\n\t            this._request = request;\n\t            evs._xhr = this;\n\t\n\t            // set handlers\n\t            request.onreadystatechange = function(){\n\t                if (request.readyState > 1 && evs.readyState != evs.CLOSED) {\n\t                    if (request.status == 200 || (request.status>=300 && request.status<400)){\n\t                        evs.ondata();\n\t                    }\n\t                    else {\n\t                        request._failed = true;\n\t                        evs.readyState = evs.CLOSED;\n\t                        evs.dispatchEvent('error', {\n\t                            type: 'error',\n\t                            data: \"The server responded with \"+request.status\n\t                        });\n\t                        evs.close();\n\t                    }\n\t                }\n\t            };\n\t\n\t            request.onprogress = function () {\n\t            };\n\t\n\t            request.open('GET', evs.urlWithParams(evs.URL, evs.getArgs), true);\n\t\n\t            var headers = evs.xhrHeaders; // maybe null\n\t            for (var header in headers) {\n\t                if (headers.hasOwnProperty(header)){\n\t                    request.setRequestHeader(header, headers[header]);\n\t                }\n\t            }\n\t            if (evs.lastEventId) {\n\t                request.setRequestHeader('Last-Event-Id', evs.lastEventId);\n\t            }\n\t\n\t            request.send();\n\t        };\n\t\n\t        EventSource.prototype.XHR.prototype = {\n\t\n\t            useXDomainRequest: false,\n\t\n\t            _request: null,\n\t\n\t            _failed: false, // true if we have had errors...\n\t\n\t            isReady: function() {\n\t\n\t\n\t                return this._request.readyState >= 2;\n\t            },\n\t\n\t            isDone: function() {\n\t\n\t                return (this._request.readyState == 4);\n\t            },\n\t\n\t            hasError: function() {\n\t\n\t                return (this._failed || (this._request.status >= 400));\n\t            },\n\t\n\t            getBuffer: function() {\n\t\n\t                var rv = '';\n\t                try {\n\t                    rv = this._request.responseText || '';\n\t                }\n\t                catch (e){}\n\t                return rv;\n\t            },\n\t\n\t            abort: function() {\n\t\n\t                if ( this._request ) {\n\t                    this._request.abort();\n\t                }\n\t            }\n\t        };\n\t    }\n\t    else {\n\t\n\t\tEventSource.isPolyfill = \"IE_8-9\";\n\t\n\t        // patch EventSource defaultOptions\n\t        var defaults = EventSource.prototype.defaultOptions;\n\t        defaults.xhrHeaders = null; // no headers will be sent\n\t        defaults.getArgs['evs_preamble'] = 2048 + 8;\n\t\n\t        // EventSource will send request using Internet Explorer XDomainRequest\n\t        EventSource.prototype.XHR = function(evs) {\n\t\n\t            request = new XDomainRequest();\n\t            this._request = request;\n\t\n\t            // set handlers\n\t            request.onprogress = function(){\n\t                request._ready = true;\n\t                evs.ondata();\n\t            };\n\t\n\t            request.onload = function(){\n\t                this._loaded = true;\n\t                evs.ondata();\n\t            };\n\t\n\t            request.onerror = function(){\n\t                this._failed = true;\n\t                evs.readyState = evs.CLOSED;\n\t                evs.dispatchEvent('error', {\n\t                    type: 'error',\n\t                    data: \"XDomainRequest error\"\n\t                });\n\t            };\n\t\n\t            request.ontimeout = function(){\n\t                this._failed = true;\n\t                evs.readyState = evs.CLOSED;\n\t                evs.dispatchEvent('error', {\n\t                    type: 'error',\n\t                    data: \"XDomainRequest timed out\"\n\t                });\n\t            };\n\t\n\t            // XDomainRequest does not allow setting custom headers\n\t            // If EventSource has enabled the use of GET arguments\n\t            // we add parameters to URL so that server can adapt the stream...\n\t            var reqGetArgs = {};\n\t            if (evs.getArgs) {\n\t\n\t                // copy evs.getArgs in reqGetArgs\n\t                var defaultArgs = evs.getArgs;\n\t                    for (var key in defaultArgs) {\n\t                        if (defaultArgs.hasOwnProperty(key)){\n\t                            reqGetArgs[key] = defaultArgs[key];\n\t                        }\n\t                    }\n\t                if (evs.lastEventId){\n\t                    reqGetArgs['evs_last_event_id'] = evs.lastEventId;\n\t                }\n\t            }\n\t            // send the request\n\t\n\t            request.open('GET', evs.urlWithParams(evs.URL,reqGetArgs));\n\t            request.send();\n\t        };\n\t\n\t        EventSource.prototype.XHR.prototype = {\n\t\n\t            useXDomainRequest: true,\n\t\n\t            _request: null,\n\t\n\t            _ready: false, // true when progress events are dispatched\n\t\n\t            _loaded: false, // true when request has been loaded\n\t\n\t            _failed: false, // true if when request is in error\n\t\n\t            isReady: function() {\n\t\n\t                return this._request._ready;\n\t            },\n\t\n\t            isDone: function() {\n\t\n\t                return this._request._loaded;\n\t            },\n\t\n\t            hasError: function() {\n\t\n\t                return this._request._failed;\n\t            },\n\t\n\t            getBuffer: function() {\n\t\n\t                var rv = '';\n\t                try {\n\t                    rv = this._request.responseText || '';\n\t                }\n\t                catch (e){}\n\t                return rv;\n\t            },\n\t\n\t            abort: function() {\n\t\n\t                if ( this._request){\n\t                    this._request.abort();\n\t                }\n\t            }\n\t        };\n\t    }\n\t\n\t    function MessageEvent(type, data, origin, lastEventId) {\n\t\n\t        this.bubbles = false;\n\t        this.cancelBubble = false;\n\t        this.cancelable = false;\n\t        this.data = data || null;\n\t        this.origin = origin || '';\n\t        this.lastEventId = lastEventId || '';\n\t        this.type = type || 'message';\n\t    }\n\t\n\t    function isOldIE () {\n\t\n\t        //return true if we are in IE8 or IE9\n\t        return (window.XDomainRequest && (window.XMLHttpRequest && new XMLHttpRequest().responseType === undefined)) ? true : false;\n\t    }\n\t\n\t    global[evsImportName] = EventSource;\n\t})(this);\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 1cb9ed232efd5edb24e0\n **/","/*\n   * CommonJS module that exports EventSource polyfill version 0.9.6\n   * This module is intended for browser side use\n   * =====================================================================\n   * THIS IS A POLYFILL MODULE, SO IT HAS SIDE EFFECTS\n   * IT AUTOMATICALLY CHECKS IF window OBJECT DEFINES EventSource\n   * AND ADD THE EXPORTED ONE IN CASE IT IS UNDEFINED\n   * =====================================================================\n   * Supported by sc AmvTek srl\n   * :email: devel@amvtek.com\n */\n\n\nvar PolyfillEventSource = require('./eventsource.js').EventSource;\nmodule.exports = PolyfillEventSource;\n\n// Add EventSource to window if it is missing...\nif (window && !window.EventSource){\n    window.EventSource = PolyfillEventSource;\n    if (console){\n\tconsole.log(\"polyfill-eventsource added missing EventSource to window\");\n    }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/eventsource-polyfill/dist/browserify-eventsource.js\n ** module id = 0\n ** module chunks = 0\n **/","/*\n   * EventSource polyfill version 0.9.6\n   * Supported by sc AmvTek srl\n   * :email: devel@amvtek.com\n */\n;(function (global) {\n\n    if (global.EventSource && !global._eventSourceImportPrefix){\n        return;\n    }\n\n    var evsImportName = (global._eventSourceImportPrefix||'')+\"EventSource\";\n\n    var EventSource = function (url, options) {\n\n        if (!url || typeof url != 'string') {\n            throw new SyntaxError('Not enough arguments');\n        }\n\n        this.URL = url;\n        this.setOptions(options);\n        var evs = this;\n        setTimeout(function(){evs.poll()}, 0);\n    };\n\n    EventSource.prototype = {\n\n        CONNECTING: 0,\n\n        OPEN: 1,\n\n        CLOSED: 2,\n\n        defaultOptions: {\n\n            loggingEnabled: false,\n\n            loggingPrefix: \"eventsource\",\n\n            interval: 500, // milliseconds\n\n            bufferSizeLimit: 256*1024, // bytes\n\n            silentTimeout: 300000, // milliseconds\n\n            getArgs:{\n                'evs_buffer_size_limit': 256*1024\n            },\n\n            xhrHeaders:{\n                'Accept': 'text/event-stream',\n                'Cache-Control': 'no-cache',\n                'X-Requested-With': 'XMLHttpRequest'\n            }\n        },\n\n        setOptions: function(options){\n\n            var defaults = this.defaultOptions;\n            var option;\n\n            // set all default options...\n            for (option in defaults){\n\n                if ( defaults.hasOwnProperty(option) ){\n                    this[option] = defaults[option];\n                }\n            }\n\n            // override with what is in options\n            for (option in options){\n\n                if (option in defaults && options.hasOwnProperty(option)){\n                    this[option] = options[option];\n                }\n            }\n\n            // if getArgs option is enabled\n            // ensure evs_buffer_size_limit corresponds to bufferSizeLimit\n            if (this.getArgs && this.bufferSizeLimit) {\n\n                this.getArgs['evs_buffer_size_limit'] = this.bufferSizeLimit;\n            }\n\n            // if console is not available, force loggingEnabled to false\n            if (typeof console === \"undefined\" || typeof console.log === \"undefined\") {\n\n                this.loggingEnabled = false;\n            }\n        },\n\n        log: function(message) {\n\n            if (this.loggingEnabled) {\n\n                console.log(\"[\" + this.loggingPrefix +\"]:\" + message)\n            }\n        },\n\n        poll: function() {\n\n            try {\n\n                if (this.readyState == this.CLOSED) {\n                    return;\n                }\n\n                this.cleanup();\n                this.readyState = this.CONNECTING;\n                this.cursor = 0;\n                this.cache = '';\n                this._xhr = new this.XHR(this);\n                this.resetNoActivityTimer();\n\n            }\n            catch (e) {\n\n                // in an attempt to silence the errors\n                this.log('There were errors inside the pool try-catch');\n                this.dispatchEvent('error', { type: 'error', data: e.message });\n            }\n        },\n\n        pollAgain: function (interval) {\n\n            // schedule poll to be called after interval milliseconds\n            var evs = this;\n            evs.readyState = evs.CONNECTING;\n            evs.dispatchEvent('error', {\n                type: 'error',\n                data: \"Reconnecting \"\n            });\n            this._pollTimer = setTimeout(function(){evs.poll()}, interval||0);\n        },\n\n\n        cleanup: function() {\n\n            this.log('evs cleaning up')\n\n            if (this._pollTimer){\n                clearInterval(this._pollTimer);\n                this._pollTimer = null;\n            }\n\n            if (this._noActivityTimer){\n                clearInterval(this._noActivityTimer);\n                this._noActivityTimer = null;\n            }\n\n            if (this._xhr){\n                this._xhr.abort();\n                this._xhr = null;\n            }\n        },\n\n        resetNoActivityTimer: function(){\n\n            if (this.silentTimeout){\n\n                if (this._noActivityTimer){\n                    clearInterval(this._noActivityTimer);\n                }\n                var evs = this;\n                this._noActivityTimer = setTimeout(\n                        function(){ evs.log('Timeout! silentTImeout:'+evs.silentTimeout); evs.pollAgain(); },\n                        this.silentTimeout\n                        );\n            }\n        },\n\n        close: function () {\n\n            this.readyState = this.CLOSED;\n            this.log('Closing connection. readyState: '+this.readyState);\n            this.cleanup();\n        },\n\n        ondata: function() {\n\n            var request = this._xhr;\n\n            if (request.isReady() && !request.hasError() ) {\n                // reset the timer, as we have activity\n                this.resetNoActivityTimer();\n\n                // move this EventSource to OPEN state...\n                if (this.readyState == this.CONNECTING) {\n                    this.readyState = this.OPEN;\n                    this.dispatchEvent('open', { type: 'open' });\n                }\n\n                var buffer = request.getBuffer();\n\n                if (buffer.length > this.bufferSizeLimit) {\n                    this.log('buffer.length > this.bufferSizeLimit');\n                    this.pollAgain();\n                }\n\n                if (this.cursor == 0 && buffer.length > 0){\n\n                    // skip byte order mark \\uFEFF character if it starts the stream\n                    if (buffer.substring(0,1) == '\\uFEFF'){\n                        this.cursor = 1;\n                    }\n                }\n\n                var lastMessageIndex = this.lastMessageIndex(buffer);\n                if (lastMessageIndex[0] >= this.cursor){\n\n                    var newcursor = lastMessageIndex[1];\n                    var toparse = buffer.substring(this.cursor, newcursor);\n                    this.parseStream(toparse);\n                    this.cursor = newcursor;\n                }\n\n                // if request is finished, reopen the connection\n                if (request.isDone()) {\n                    this.log('request.isDone(). reopening the connection');\n                    this.pollAgain(this.interval);\n                }\n            }\n            else if (this.readyState !== this.CLOSED) {\n\n                this.log('this.readyState !== this.CLOSED');\n                this.pollAgain(this.interval);\n\n                //MV: Unsure why an error was previously dispatched\n            }\n        },\n\n        parseStream: function(chunk) {\n\n            // normalize line separators (\\r\\n,\\r,\\n) to \\n\n            // remove white spaces that may precede \\n\n            chunk = this.cache + this.normalizeToLF(chunk);\n\n            var events = chunk.split('\\n\\n');\n\n            var i, j, eventType, datas, line, retry;\n\n            for (i=0; i < (events.length - 1); i++) {\n\n                eventType = 'message';\n                datas = [];\n                parts = events[i].split('\\n');\n\n                for (j=0; j < parts.length; j++) {\n\n                    line = this.trimWhiteSpace(parts[j]);\n\n                    if (line.indexOf('event') == 0) {\n\n                        eventType = line.replace(/event:?\\s*/, '');\n                    }\n                    else if (line.indexOf('retry') == 0) {\n\n                        retry = parseInt(line.replace(/retry:?\\s*/, ''));\n                        if(!isNaN(retry)) {\n                            this.interval = retry;\n                        }\n                    }\n                    else if (line.indexOf('data') == 0) {\n\n                        datas.push(line.replace(/data:?\\s*/, ''));\n                    }\n                    else if (line.indexOf('id:') == 0) {\n\n                        this.lastEventId = line.replace(/id:?\\s*/, '');\n                    }\n                    else if (line.indexOf('id') == 0) { // this resets the id\n\n                        this.lastEventId = null;\n                    }\n                }\n\n                if (datas.length) {\n                    // dispatch a new event\n                    var event = new MessageEvent(eventType, datas.join('\\n'), window.location.origin, this.lastEventId);\n                    this.dispatchEvent(eventType, event);\n                }\n            }\n\n            this.cache = events[events.length - 1];\n        },\n\n        dispatchEvent: function (type, event) {\n            var handlers = this['_' + type + 'Handlers'];\n\n            if (handlers) {\n\n                for (var i = 0; i < handlers.length; i++) {\n                    handlers[i].call(this, event);\n                }\n            }\n\n            if (this['on' + type]) {\n                this['on' + type].call(this, event);\n            }\n\n        },\n\n        addEventListener: function (type, handler) {\n            if (!this['_' + type + 'Handlers']) {\n                this['_' + type + 'Handlers'] = [];\n            }\n\n            this['_' + type + 'Handlers'].push(handler);\n        },\n\n        removeEventListener: function (type, handler) {\n            var handlers = this['_' + type + 'Handlers'];\n            if (!handlers) {\n                return;\n            }\n            for (var i = handlers.length - 1; i >= 0; --i) {\n                if (handlers[i] === handler) {\n                    handlers.splice(i, 1);\n                    break;\n                }\n            }\n        },\n\n        _pollTimer: null,\n\n        _noactivityTimer: null,\n\n        _xhr: null,\n\n        lastEventId: null,\n\n        cache: '',\n\n        cursor: 0,\n\n        onerror: null,\n\n        onmessage: null,\n\n        onopen: null,\n\n        readyState: 0,\n\n        // ===================================================================\n        // helpers functions\n        // those are attached to prototype to ease reuse and testing...\n\n        urlWithParams: function (baseURL, params) {\n\n            var encodedArgs = [];\n\n            if (params){\n\n                var key, urlarg;\n                var urlize = encodeURIComponent;\n\n                for (key in params){\n                    if (params.hasOwnProperty(key)) {\n                        urlarg = urlize(key)+'='+urlize(params[key]);\n                        encodedArgs.push(urlarg);\n                    }\n                }\n            }\n\n            if (encodedArgs.length > 0){\n\n                if (baseURL.indexOf('?') == -1)\n                    return baseURL + '?' + encodedArgs.join('&');\n                return baseURL + '&' + encodedArgs.join('&');\n            }\n            return baseURL;\n        },\n\n        lastMessageIndex: function(text) {\n\n            var ln2 =text.lastIndexOf('\\n\\n');\n            var lr2 = text.lastIndexOf('\\r\\r');\n            var lrln2 = text.lastIndexOf('\\r\\n\\r\\n');\n\n            if (lrln2 > Math.max(ln2, lr2)) {\n                return [lrln2, lrln2+4];\n            }\n            return [Math.max(ln2, lr2), Math.max(ln2, lr2) + 2]\n        },\n\n        trimWhiteSpace: function(str) {\n            // to remove whitespaces left and right of string\n\n            var reTrim = /^(\\s|\\u00A0)+|(\\s|\\u00A0)+$/g;\n            return str.replace(reTrim, '');\n        },\n\n        normalizeToLF: function(str) {\n\n            // replace \\r and \\r\\n with \\n\n            return str.replace(/\\r\\n|\\r/g, '\\n');\n        }\n\n    };\n\n    if (!isOldIE()){\n\n        EventSource.isPolyfill = \"XHR\";\n\n        // EventSource will send request using XMLHttpRequest\n        EventSource.prototype.XHR = function(evs) {\n\n            request = new XMLHttpRequest();\n            this._request = request;\n            evs._xhr = this;\n\n            // set handlers\n            request.onreadystatechange = function(){\n                if (request.readyState > 1 && evs.readyState != evs.CLOSED) {\n                    if (request.status == 200 || (request.status>=300 && request.status<400)){\n                        evs.ondata();\n                    }\n                    else {\n                        request._failed = true;\n                        evs.readyState = evs.CLOSED;\n                        evs.dispatchEvent('error', {\n                            type: 'error',\n                            data: \"The server responded with \"+request.status\n                        });\n                        evs.close();\n                    }\n                }\n            };\n\n            request.onprogress = function () {\n            };\n\n            request.open('GET', evs.urlWithParams(evs.URL, evs.getArgs), true);\n\n            var headers = evs.xhrHeaders; // maybe null\n            for (var header in headers) {\n                if (headers.hasOwnProperty(header)){\n                    request.setRequestHeader(header, headers[header]);\n                }\n            }\n            if (evs.lastEventId) {\n                request.setRequestHeader('Last-Event-Id', evs.lastEventId);\n            }\n\n            request.send();\n        };\n\n        EventSource.prototype.XHR.prototype = {\n\n            useXDomainRequest: false,\n\n            _request: null,\n\n            _failed: false, // true if we have had errors...\n\n            isReady: function() {\n\n\n                return this._request.readyState >= 2;\n            },\n\n            isDone: function() {\n\n                return (this._request.readyState == 4);\n            },\n\n            hasError: function() {\n\n                return (this._failed || (this._request.status >= 400));\n            },\n\n            getBuffer: function() {\n\n                var rv = '';\n                try {\n                    rv = this._request.responseText || '';\n                }\n                catch (e){}\n                return rv;\n            },\n\n            abort: function() {\n\n                if ( this._request ) {\n                    this._request.abort();\n                }\n            }\n        };\n    }\n    else {\n\n\tEventSource.isPolyfill = \"IE_8-9\";\n\n        // patch EventSource defaultOptions\n        var defaults = EventSource.prototype.defaultOptions;\n        defaults.xhrHeaders = null; // no headers will be sent\n        defaults.getArgs['evs_preamble'] = 2048 + 8;\n\n        // EventSource will send request using Internet Explorer XDomainRequest\n        EventSource.prototype.XHR = function(evs) {\n\n            request = new XDomainRequest();\n            this._request = request;\n\n            // set handlers\n            request.onprogress = function(){\n                request._ready = true;\n                evs.ondata();\n            };\n\n            request.onload = function(){\n                this._loaded = true;\n                evs.ondata();\n            };\n\n            request.onerror = function(){\n                this._failed = true;\n                evs.readyState = evs.CLOSED;\n                evs.dispatchEvent('error', {\n                    type: 'error',\n                    data: \"XDomainRequest error\"\n                });\n            };\n\n            request.ontimeout = function(){\n                this._failed = true;\n                evs.readyState = evs.CLOSED;\n                evs.dispatchEvent('error', {\n                    type: 'error',\n                    data: \"XDomainRequest timed out\"\n                });\n            };\n\n            // XDomainRequest does not allow setting custom headers\n            // If EventSource has enabled the use of GET arguments\n            // we add parameters to URL so that server can adapt the stream...\n            var reqGetArgs = {};\n            if (evs.getArgs) {\n\n                // copy evs.getArgs in reqGetArgs\n                var defaultArgs = evs.getArgs;\n                    for (var key in defaultArgs) {\n                        if (defaultArgs.hasOwnProperty(key)){\n                            reqGetArgs[key] = defaultArgs[key];\n                        }\n                    }\n                if (evs.lastEventId){\n                    reqGetArgs['evs_last_event_id'] = evs.lastEventId;\n                }\n            }\n            // send the request\n\n            request.open('GET', evs.urlWithParams(evs.URL,reqGetArgs));\n            request.send();\n        };\n\n        EventSource.prototype.XHR.prototype = {\n\n            useXDomainRequest: true,\n\n            _request: null,\n\n            _ready: false, // true when progress events are dispatched\n\n            _loaded: false, // true when request has been loaded\n\n            _failed: false, // true if when request is in error\n\n            isReady: function() {\n\n                return this._request._ready;\n            },\n\n            isDone: function() {\n\n                return this._request._loaded;\n            },\n\n            hasError: function() {\n\n                return this._request._failed;\n            },\n\n            getBuffer: function() {\n\n                var rv = '';\n                try {\n                    rv = this._request.responseText || '';\n                }\n                catch (e){}\n                return rv;\n            },\n\n            abort: function() {\n\n                if ( this._request){\n                    this._request.abort();\n                }\n            }\n        };\n    }\n\n    function MessageEvent(type, data, origin, lastEventId) {\n\n        this.bubbles = false;\n        this.cancelBubble = false;\n        this.cancelable = false;\n        this.data = data || null;\n        this.origin = origin || '';\n        this.lastEventId = lastEventId || '';\n        this.type = type || 'message';\n    }\n\n    function isOldIE () {\n\n        //return true if we are in IE8 or IE9\n        return (window.XDomainRequest && (window.XMLHttpRequest && new XMLHttpRequest().responseType === undefined)) ? true : false;\n    }\n\n    global[evsImportName] = EventSource;\n})(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/eventsource-polyfill/dist/eventsource.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}